#' @title Plot Marginal Effects Estimates
#' @description Implementation of Stata's \samp{marginsplot} as an S3 generic function
#' @param x An object of class \dQuote{margins}, as returned by \code{\link{margins}}.
#' @param at A numeric vector specifying the x-positions of the estimates (or y-positions, if \code{horizontal = TRUE}).
#' @param which A character vector specifying which marginal effect estimate to plot. Default is all.
#' @param labels A character vector specifying the axis labels to use for the marginal effect estimates. Default is the variable names from \code{x}.
#' @param horizontal A logical indicating whether to plot the estimates along the x-axis with vertical confidence intervals (the default), or along the y-axis with horizontal confidence intervals.
#' @param xlab A character string specifying the x-axis (or y-axis, if \code{horizontal = TRUE}) label.
#' @param ylab A character string specifying the y-axis (or x-axis, if \code{horizontal = TRUE}) label.
#' @param level A numeric value between 0 and 1 indicating the confidence level to use when drawing error bars.
#' @param pch The point symbol to use for plotting marginal effect point estimates. See \code{\link[graphics]{points}} for details.
#' @param points.col The point color to use for plotting marginal effect point estimates. See \code{\link[graphics]{points}} for details.
#' @param points.bg The point color to use for plotting marginal effect point estimates. See \code{\link[graphics]{points}} for details.
#' @param las An integer value specifying the orientation of the axis labels. See \code{\link[graphics]{par}} for details.
#' @param cex A numerical value giving the amount by which plotting text and symbols should be magnified relative to the default. See \code{\link[graphics]{par}} for details.
#' @param lwd A numerical value giving the width of error bars in points.
#' @param zeroline A logical indicating whether to draw a line indicating zero. Default is \code{TRUE}.
#' @param zero.col A character string indicating a color to use for the zero line if \code{zeroline = TRUE}.
#' @param \dots Additional arguments passed to \code{\link[graphics]{plot.default}}, such as \code{title}, etc.
#' @details This function is invoked for its side effect: a basic dot plot with error bars displaying marginal effects as generated by \code{\link{margins}}, in the style of Stata's \samp{marginsplot} command.
#' @return Object \code{x}, invisibly.
#' @seealso \code{\link{margins}}
#' @importFrom graphics abline axis plot points segments
#' @export
plot.margins <- 
function(x, 
         at = seq_along(extract_marginal_effects(x)),
         which = colnames(extract_marginal_effects(x)), 
         labels = which,
         horizontal = FALSE,
         xlab = "",
         ylab = "Marginal Effect",
         level = 0.95,
         pch = 21, 
         points.col = "black",
         points.bg = "black",
         las = 1,
         cex = 1,
         lwd = 2, 
         zeroline = TRUE,
         zero.col = "gray",
         ...) {
    
    MEs <- colMeans(extract_marginal_effects(x)[, which, drop = FALSE])
    quantiles <- qnorm(cbind((1-sort(level))/2, 1-(1-sort(level))/2))
    maxl <- max(abs(quantiles))
    variances <- attributes(x)[["Variances"]]
    lb <- MEs - (maxl * sqrt(variances))
    ub <- MEs + (maxl * sqrt(variances))
    r <- max(ub) - min(lb)
    if (isTRUE(horizontal)) {
        plot(NA, xlim = c(min(lb)-0.04*r, max(ub)+0.04*r),
                 ylim = c(min(at)-(0.04*min(at)), max(at) + (0.04*max(at))), 
                 yaxt = 'n', xlab = ylab, ylab = xlab, las = las, ...)
        if (zeroline) {
            abline(v = 0, col = zero.col)
        }
        points(MEs, at, col = points.col, bg = points.bg, pch = pch)
        axis(2, at = at, labels = as.character(labels), las = las)
        mapply(function(z, lwd) {
            segments(MEs + (quantiles[z,1] * sqrt(variances)), at, 
                     MEs + (quantiles[z,2] * sqrt(variances)), at, 
                     col = points.col, lwd = lwd)
        }, 1:nrow(quantiles), seq(max(lwd), 0.25, length.out = nrow(quantiles)))
    } else {
        plot(NA, xlim = c(min(at)-(0.04*min(at)), max(at) + (0.04*max(at))), 
                 ylim = c(min(lb)-0.04*r, max(ub)+0.04*r), 
                 xaxt = 'n', xlab = xlab, ylab = ylab, las = las, ...)
        if (zeroline) {
            abline(h = 0, col = zero.col)
        }
        points(at, MEs, col = points.col, bg = points.bg, pch = pch)
        axis(1, at = at, labels = as.character(labels), las = las)
        mapply(function(z, lwd) {
            segments(at, MEs + (quantiles[z,1] * sqrt(variances)), 
                     at, MEs + (quantiles[z,2] * sqrt(variances)), 
                     col = points.col, lwd = lwd)
        }, 1:nrow(quantiles), seq(max(lwd), 0.25, length.out = nrow(quantiles)))
    }
    invisible(x)
}
