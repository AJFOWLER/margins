#' @title Marginal Effects Calculator
#' @description This is the low-level marginal effects calculator called by \code{\link{margins}}.
#' @param x A model object.
#' @param data A data.frame. If missing, data are extracted from the \code{x}.
#' @param atmeans A logical indicating whether to estimate \dQuote{marginal effects at means} or \dQuote{average marginal effects} (the default).
#' @param type A character string indicating the type of marginal effects to estimate. Mostly relevant for non-linear models, where the reasonable options are \dQuote{response} (the default) or \dQuote{link} (i.e., on the scale of the linear predictor in a GLM).
#' @param vce A character string indicating the type of estimation procedure to use for estimating variances. The default (\dQuote{delta}) uses the delta method. Alternatives are \dQuote{bootstrap}, which uses bootstrap estimation, or \dQuote{simulation}, which averages across simulations drawn from the joint sampling distribution of model coefficients. The latter two are extremely time intensive.
#' @param iterations If \code{vce = "bootstrap"}, the number of bootstrap iterations. If \code{vce = "simulation"}, the number of simulated effects to draw. Ignored otherwise.
#' @param method A character string indicating the numeric derivative method to use when estimating marginal effects. See \code{\link[numDeriv]{grad}} for details.
#' @param \dots Ignored.
#' @return A data.frame of class \dQuote{margins} containing the contents of \code{data}, fitted values for \code{x}, and any estimated marginal effects. Attributes containing additional information, including the marginal effect variances and additional details.
#' @import stats
#' @importFrom numDeriv grad
#' @importFrom MASS mvrnorm
#' @export
marginal_effect <- 
function(x, 
         data,
         atmeans = FALSE, 
         type = c("response", "link", "terms"),
         vce = c("delta", "bootstrap", "simulation"),
         iterations = 500L, # if vce == "bootstrap" or "simulation"
         method = c("Richardson", "simple", "complex"), # passed to get_slopes()
         ...) {
    
    # variables in the model
    allvars <- attributes(terms(x))$term.labels[attributes(terms(x))$order == 1]
    allvars <- sort(.cleanterms(allvars))
    
    # setup data
    if (missing(data)) {
        d <- eval(x[["call"]][["data"]], parent.frame())
        dat <- if (!is.null(d)) d else x[["model"]]
        rm(d)
    } else {
        dat <- data
    }
    if (atmeans) {
        # optionally pass to .atmeans
        # need to be able to tell .atmeans which vars to set to means
        dat <- .atmeans(dat, vars = names(dat), na.rm = TRUE)
    }
    
    type <- match.arg(type)
    
    # obtain predicted values and standard errors
    pred <- stats::predict(x, newdata = data, type = type, se.fit = TRUE)
    pred.se <- pred[[2]]
    pred <- pred[[1]]
    
    # obtain gradient with respect to each variable in data
    ## THIS DOES NOT HANDLE DISCRETE FACTORS
    grad <- get_slopes(dat, model = x, type = type, method = method)[, allvars, drop = FALSE]
    if (inherits(x, "glm") && type == "response") {
        pred <- get_prediction(dat, model = x, type = "response")
        tmp <- lapply(grad, `*`, pred)
        rm(pred)
        rownames(tmp) <- rownames(grad)
        grad <- tmp
        rm(tmp)
    }
    
    # variance estimation technique
    vce <- match.arg(vce)
    # model variance-covariance matrix
    vc <- vcov(x)
    
    if (vce == "bootstrap") {
        # function to calculate AME for one bootstrap subsample
        bootfun <- function() {
            s <- sample(1:nrow(dat), nrow(dat), TRUE)
            colMeans(get_slopes(dat[s,], model = x, type = type, method = method)[, allvars, drop = FALSE], na.rm = TRUE)
        }
        # bootstrap the data and take the variance of bootstrapped AMEs
        variances <- apply(replicate(iterations, bootfun()), 2, var, na.rm = TRUE)
    } else if (vce == "delta") {
        
        # express each marginal effect as a function of all coefficients
        # holding data constant (maybe just atmeans to start)
        # this is what .build_grad_fun() will do
        # then:  numDeriv::grad(.build_grad_fun(), x$coef)
        # gives `gradmat`, such that v %*% V %*% t(v)
        # gives the variance of each marginal effect
        # `gradmat` should be an ME-by-beta matrix
        
        # http://www.soderbom.net/lecture10notes.pdf
        # http://stats.stackexchange.com/questions/122066/how-to-use-delta-method-for-standard-errors-of-marginal-effects
        
        gradmat <- do.call("rbind", lapply(allvars, function(thisme) {
            FUN <- .build_grad_fun(data = dat, model = x, which_me = thisme, atmeans = TRUE, type = type, method = method)
            numDeriv::grad(FUN, x[["coefficients"]])
        }))
        variances <- diag(gradmat %*% vc %*% t(gradmat))
    } else if (vce == "simulation") {
        
        # copy model for quick use in estimation
        tmpmodel <- x
        tmpmodel$model <- NULL # remove data from model for memory
        
        # simulate from multivariate normal
        coefmat <- MASS::mvrnorm(iterations, coef(x), vcov(x))
        
        # estimate AME from from each simulated coefficient vector
        effectmat <- apply(coefmat, 1, function(coefrow) {
            tmpmodel[["coefficients"]] <- coefrow
            colMeans(get_slopes(dat, model = tmpmodel, type = type, method = method)[, allvars, drop = FALSE])
        })
        # calculate the variance of the simulated AMEs
        variances <- apply(effectmat, 1, var, na.rm = TRUE)
    }
    
    # obtain predicted values and standard errors
    pred <- stats::predict(x, newdata = data, type = type, se.fit = TRUE)
    class(pred[["fit"]]) <- c("fit", "numeric")
    class(pred[["se.fit"]]) <- c("se.fit", "numeric")
    
    # set output classes
    for (i in seq_along(grad)) {
        class(grad[[i]]) <- c("marginaleffect", "numeric")
    }
    
    structure(cbind(dat, fit = pred[["fit"]], se.fit = pred[["se.fit"]], grad), 
              class = c("margins", "data.frame"), 
              Variances = variances,
              type = type,
              atmeans = atmeans, 
              call = x[["call"]],
              df.residual = x[["df.residual"]],
              vce = vce, 
              call = call,
              iterations = iterations)
}
